
# 待查询Lremalloc
# 不一样
grow那个不一样
# 缓冲区定义
缓冲区（Buffer）是计算机程序中用来临时存储数据的内存区域，它通常用于处理输入/输出操作，或者为了提高程序的效率而存储数据，特别是在处理文件读写、网络通信等操作时。简单来说，缓冲区是一个“暂时存放”数据的区域，通常用于弥补数据传输的速度差异，避免频繁的读写操作。
通常以固定大小初始化，但这可能导致空间不足或浪费。
动态扩容：

当缓冲区空间不足时，通过重新分配更大的内存块来满足数据需求。
避免内存泄漏、提高资源利用率。
适用场景：

文件读取、网络通信、字符串拼接等需要动态调整存储空间的场景。
- How: 实现动态扩容缓冲区

# part1  字符串缓冲区基本架构：
初始化一个固定大小的缓冲区。
检测是否需要扩容（如缓冲区已满）。
分配一个更大的缓冲区，将原数据复制到新缓冲区。
释放旧缓冲区，更新指针。
设计步骤：

初始化缓冲区：设定初始大小（如 16 字节）。
扩容机制：通常以倍数增长，如 2 倍扩容。
内存管理：使用 malloc 和 realloc 动态分配和调整内存。

- struct MyStruct *ptr
ptr 是一个指向 MyStruct 类型的指针,==但是指向谁还没告诉你呢!!==

指针左边是类型,右边是实际指向的东西!!!
它需要指向一个实际分配的结构体实例，才能正确地操作该实例的成员（比如 例alloc、len 和 buf）。

- 结构体访问成员:
通过结构体实例：使用点运算符（.）来访问成员。
通过结构体指针：使用箭头运算符（->）来访问成员。

==->== 运算符是 解引用指针并访问成员 的简写，它结合了 解引用 和 成员访问 两个操作.就是解应用得到原对象再访问

malloc  转型&大小
> 内存分配和未初始化的内存 当你使用 malloc 分配内存时，操作系统为你分配了指定大小的内存块，但这块内存的内容是 未初始化的。也就是说，malloc 只负责分配内存空间，并不会对空间里的数据进行任何初始化，内存块中的值是随机的，可能是垃圾数据

> 初始化思路:
划分一块内存,并保证里面什么都不存储

## why这个函数不用释放(free)
函数本身的职责是初始化一个 struct strbuf，为其分配内存和初始化内容，而不是负责释放内存。释放内存的责任一般交由调用方或其他清理函数来完成，这是 C 语言内存管理的常见设计模式，称为“谁分配，谁释放”。谁用了...再释放
==如果直接释放了,等于这个函数用完,那个内存还是无效的,没用呀==

下面是更详细的分析：

1. 分配内存但不释放
sb->buf = (char*)malloc(alloc);
在 strbuf_init 中使用 malloc 为 sb->buf 分配内存。此内存是动态分配的，它的生命周期由程序控制。如果在这个函数内直接调用 free，那么分配的内存会被立刻释放，导致 sb->buf 指向的内存无效。调用方在后续使用 strbuf 时就会出错。

2. 释放的责任在调用方
为了保证灵活性，C 语言中常会将内存释放的职责交由使用该数据的调用方。例如：

strbuf_init 负责分配和初始化内存。
程序的其他部分负责在不需要 strbuf 时调用适当的清理函数。
一个常见的设计是提供一个配套的清理函数，例如：
void strbuf_release(struct strbuf *sb) {
    free(sb->buf);
    sb->buf = NULL;  // 防止悬空指针
    sb->alloc = 0;
    sb->len = 0;
}
3. 为何分开设计分配和释放
这样的设计遵循模块化和职责分离的原则：

初始化函数 (strbuf_init) 专注于准备使用的数据结构。
释放函数 (strbuf_release) 专注于释放资源。
这样可以避免重复代码，并且更易于维护和调试。例如，程序的不同部分可以调用初始化函数而不需要了解释放细节。


## len 和 alloc 单位为什么可以一致？
在 C 语言中，字符串是由一串 字符（char） 组成的，而每个 char 占用 1 字节。因此：

- ==len==（长度） 表示当前字符串中包含的字符个数。

    例如："hello" 的长度是 5（不包括 \0）。
每个字符占 1 字节，因此长度直接等同于占用的字节数。
    - len代表实际存储
- ==alloc==（容量） 表示分配的字节总数，用于存储字符串和可能的空余空间。

    由于字符串中每个字符占用 1 字节，len 和 alloc 的单位都可以直接理解为 字节数。因此在比较时，不会有单位不一致的问题。
    - alloc是最大存储

> 内存的特性：
在程序运行时，系统为程序分配一片连续的内存空间，这其中包括用于存储数据的缓冲区。
指针的作用是保存某个内存地址，通过指针可以访问或操作该内存地址所存储的数据。
所以，当我们有一个指针（如 char *buf），并将它指向一片分配的内存（缓冲区），这个指针就能代表并操作缓冲区。

> 所以,首先缓冲区的表示:
我们在结构体里面要声明一个指针,指针来指向这个缓冲区
再附上缓冲区的最大容量和实际长度的声明

> 指针赋值
指针可以指向一个变量,也可以指向一个动态分配内存的首地址.

> 辨析:
## 指针数组,数组指针与指针下标访问
first,方括号优先级别高
==指针数组==,数组每个元素对应一个指针,所以是int *ptr[10]
> - ptr是主体,他是数组,他先和[]结合,然后这个数组的每一个元素类型是int *
类比一下 int a[10],a是主体,他是数组,他先和[]结合,然后这个数组的每一个元素类型是int
> - 好理解--前面是元素类型,后面是数组名字和元素个数
读也是先说数组类型,再说数组名字
>
> ==数组指针==
int (*ptr)[5];  
ptr和*结合,表示这是一个指针,然后这个指针指向一个数组,这个数组的元素类型是int,数组长度是5
注意数组指针和指针数组的主体都是那个名字!!
int[5]*p不合法,因为int[5] 代表了一个固定大小的数组类型，而指针是用于指向数据的，因此你不能声明一个指针类型为 int[5]，这会导致语法错误。
你的理解是 **正确的**！让我详细解释一下：

#指针和数组的关系：
- **指针本质上是存储地址的**，它可以指向一个元素（如一个 `int` 变量），也可以指向一个整体（如一个数组）。但是，指针永远是指向某个 **数据类型** 的首地址，而 **数组的本质是连续存储的一组元素**。

- **指向数组**的指针，实际上是指向数组的 **首元素**。
> 为什么 `int[5] *p` 错误？
- `int[5]` 是数组类型，它表示一个包含 5 个 `int` 元素的数组。**数组本身并不是一个数据类型**，它是由多个元素组成的复合类型。因此，在 C 语言中不能直接用 `int[5]` 来声明指向数组的指针类型。
  
- **`*p` 表示指针**，而指针必须指向一个数据类型（如 `int`，`char`，或者其他复合数据类型）。**不能把数组类型直接作为指针的目标**。数组名（如 `arr`）虽然在某些上下文中可以作为指针，但在声明指针时，数组的大小不能直接作为指针类型的一部分。
你说的“指针本质上是指向那个整体的首元素”完全正确！


int(*p)[5]
虽然 int (*p)[5] 这个声明给出了指针的类型信息，但 p 指向谁，实际上是通过赋值来确定的。换句话说，声明只指定了类型，但并没有指定指针的目标。
例如：
int arr[5] = {10, 20, 30, 40, 50};  // 一个包含 5 个 int 的数组
int (*p)[5] = &arr;  // p 被赋值为指向 arr 数组的指针
> ==(*p)[5] 是一种 类型声明，告诉编译器 p 是指向 数组 的指针，而不是指向单个元素的指针==
int*p默认是指向单个元素

> 意思是,p指向的元素是数组元素,然后他本质对应这个数组的首地址,然后这个数组每个数据都对应int类型.不冲突
p[0] 表示数组的第一个元素（int 类型）。
p[1] 表示数组的第二个元素，以此类推。

> ==指针下标访问==
指针下标访问和数组下标访问非常相似，但其底层实现方式稍有不同。我们可以将 p[i] 视为等价于 *(p + i)，这两者的含义是一样的，p[i] 会访问指针 p 偏移 i 个位置后的内存内容。
p[i] 本质上是 *(p + i)。
指针加[]就代表对应偏移量的值
tip 而数组名本身也代表了指针指向第一个元素的地址,所以数组加[]代表偏移量的值

> - 为什么缓冲区有一个元素
缓冲区的第一个元素通常是存在的，即使没有有效的字符。原因如下：
内存分配：如果你已经为 buf 分配了内存（即使是空的），它会有一个地址，buf[0] 就是内存中的第一个位置。即使没有写入有效字符，buf 在内存中也存在这个位置。

>
> - 标志缓冲区为空：通过设置第一个字符为 '\0'，我们确保这个缓冲区是一个有效的字符串，且它目前为空（==而不仅仅是一个未初始化的内存块==）。
初始化!!
避免未初始化内存：如果你没有明确地为缓冲区的第一个元素赋值，buf 可能包含未初始化的数据。这会导致不确定的行为，因为读取未初始化的内存会得到不确定的值。
# part2初始化缓冲区
给到指针以及最大容量后,将缓冲区指向要分配的内存--
> 然后将指针指向的结构体(地球)更新要求
更新实际和最大,基本信息+更新划分了一块地(指针指向了分配的内存)
长度就是buf[]内的东西,代表实际,是为buf服务的,肯定得要

> ----所以==len alloc  sb就是buf本身和最大的意思==
tip在 C 语言中，结构体成员只能通过结构体变量来访问。因此，不能单独使用 len
# part3缓冲区添加字符串
> 不用初始化:
strbuf_attach 不是在创建一个新的缓冲区，而是将一个已经存在的缓冲区==(这个代码是一连串的意思,我们的buf建立的时候已经初始化过了)==（即 str）与 strbuf 结构体关联
不需要重新分配或初始化缓冲区：外部已经提供了一个有效的内存区域（通过 str），因此没有必要再次进行内存分配或初始化


何时需要初始化？
如果是分配新的缓冲区（例如在 strbuf_init 函数中），你通常需要初始化缓冲区的内容，例如设置第一个字符为 '\0'，以标识缓冲区为空。而在 strbuf_attach 中，由于 str 是外部提供的缓冲区，所以只需要将 str 直接赋值给 sb->buf，无需进行初始化操作

## 指针可以直接等于指针
在 C 语言中，指针存储的是一个地址，指向某个内存位置。你可以将一个指针变量赋值给另一个指针变量，意思是让它们都指向同一个内存位置,==数组名是常量指针==
==记得进行类型转换==
# part4 释放
- free是释放内存块,null是让指针归零
指针指向内存块,再把它销毁.要两个操作,一个是针对内存块,一个是针对指针(如果指针仍指向那个地方,就是悬空指针!!)
悬空指针（dangling pointer）指的是一个指针，它指向一个已经被释放的内存区域。这种指针仍然持有原来地址的信息，但该地址的内存已经被释放或重新分配，导致指针指向的内存不再有效

将指针设置为 NULL 的意思是将指针的值设为零，表示该指针不指向任何有效的内存地址或对象,在 C 语言中，NULL 是一个==常量==，它的值通常是 0，并且被用来标识指针为空或未初始化,二次释放。这种操作是非法的，会导致未定义行为，可能导致程序崩溃或内存泄漏。
- 在调用 free() 释放内存后，立刻将指针设置为 NULL。这样，即使后续代码中再次调用 free()，也不会发生错误，因为 free(NULL) 是安全的，不会对 NULL 做任何操作

> 注意!要把buf设置成null,不可以直接赋值
## 为什么不直接sb->bu=null,要再调用attach函数
> 
> sb->buf = NULL 只是将指针清空，==内存的释放和相关字段的更新没有被完整处理==。而通过 strbuf_attach，可以确保在修改指针后，len 和 alloc 也得到适当更新，保持 strbuf 结构体的整体一致性。

## 为什么可以把 NULL 作为 void* 类型传递？
NULL 是空指针常量： 在 C 语言中，NULL 是一个常量，表示指向任何类型的指针为空。通常，NULL 被定义为 (void *)0，它可以赋值给任何类型的指针，意味着它可以被传递给接受 void * 类型参数的函数。
# part5 交换缓冲区
## 可以直接实现缓冲区的交换
在 C 中，结构体支持整体赋值。*a = *b; 的含义是将 b 结构体的所有字段（len、alloc 和 buf）的值拷贝到 a 结构体中
- 这里直接利用中介交换就好了
注意,交换的是结构体,不是指针a和b,所以是结构体t=*a,不是a
如果结构体里没有指针,可以直接拷贝
如果有,则想一想深浅拷贝
浅拷贝赋值的结果就是他们共用一块内存地址

这里可以浅拷贝,如果你不想处理深拷贝的复杂性，有一个办法是==手动控制内存的分配和释放== ，避免指针多次指向同一块内存
## ==我错:== 指针等于指针,并不会交换对象的值
而且,要实现交换,也必须要借助第三方,指针a=指针b的交换方法是非常错误的.
假设借助了第三方,a和b的地址发生了交换,他们的值也没有改变!!我之前一直把地址当成变量来理解,以为值也一起变了(这里很难理解,最后借助gpt举例子突然就悟到了,所以要多让他举例子)
ifa,b前面的就是他们的地址
@a=1,%b=2,交换地址后,%a=1,@b=2,a,b他们的值并没有改变!!!!


### 内存,指针,指针变量,内存与指针的关系
- 内存是暂时存储数据用的,内存中每一个数据都会分配对应的地址,int占4个字节,就对应分配四个地址.(即每个内存单元都有一个编号,这个编号就是地址,也就是指针)
- 指针是内存单元的编号,指针变量就是存放==地址==的一个变量.两个东西不同,但是平常把指针变量简称为指针
> ==指针=内存编号=地址
指针变量=存放地址的变量(简称指针,但和上面那个不是一回事)==


## ==?== 深拷贝
void strbuf_deep_swap(struct strbuf *a, struct strbuf *b) {
    struct strbuf temp;

    // 深拷贝 a 的数据到 temp
    temp.len = a->len;
    temp.alloc = a->alloc;
    temp.buf = malloc(a->alloc);
    memcpy(temp.buf, a->buf, a->len);

    // 深拷贝 b 的数据到 a
    a->len = b->len;
    a->alloc = b->alloc;
    free(a->buf);
    a->buf = malloc(b->alloc);
    memcpy(a->buf, b->buf, b->len);

    // 深拷贝 temp 的数据到 b
    b->len = temp.len;
    b->alloc = temp.alloc;
    free(b->buf);
    b->buf = malloc(temp.alloc);
    memcpy(b->buf, temp.buf, temp.len);

    free(temp.buf);
}


## 之前那个不可以直接 *sb = NULL。原因是：

1. *sb 的意义
*sb 是 struct strbuf 类型的值，代表整个结构体的内容。你要修改的是 sb 指向的结构体，而不是试图把整个结构体变成空指针。那个null只有一个指针值的意思

2. NULL 是一个指针，不是结构体值
NULL 表示空指针，用来初始化指针变量。直接写 *sb = NULL 意味着你试图将整个 struct strbuf 赋值为一个“空指针”，这是不合法的，因为：

sb 本身是指向结构体的指针，而结构体和指针的概念完全不同。
==*sb 期望的值是一个结构体==，而不是一个指针值。
## null不可以解应用
如果一个指针的值是 NULL，意味着它没有指向任何有效的内存地址
NULL 是一个无效的地址：它的值是 0，在绝大多数系统中，地址 0 不被分配给程序使用
由于地址 0 不属于你的程序，操作系统会检测到非法访问，导致程序崩溃（通常会抛出“段错误”或“访问冲突”）
# 取出内存
## strbuf_detach 函数的作用
从 strbuf 结构体中“分离”出缓冲区，让调用者能够直接操作该缓冲区，并且不再让 strbuf 结构体继续管理这个内存。这个操作本质上是让调用者接管内存，而不再依赖结构体对内存的管理
## how取出来
返回指针就是取出来了
> 调用 strbuf_detach 后，缓冲区的指针被返回给调用者。这意味着，结构体 strbuf 不再持有缓冲区的指针，而是将管理权转移给了调用者。

## return的作用
- 指针返回：如果返回的是指向堆上分配内存的指针，通常所有权会转移给调用者，调用者需要负责==释放内存==。
- 局部变量的指针返回：如果返回的是指向局部变量的指针，所有权没有转移，返回的是悬挂指针，应该避免。
如果本来那个东西生命周期就是整个程序,那么返回回补返回所有权
- 如果函数返回指向全局变量或静态变量的指针，所有权没有转移，因为这些变量的生命周期是整个程序运行期间都存在的。调用者不需要负责释放内存
全局变量的所有权==属于程序==
## 所有权在调用者身上
想一想堆区
当我们说“所有权在调用者身上”，通常意味着函数返回了某个资源（例如内存块、文件句柄、指针等），并且调用者需要负责对这个资源的生命周期进行管理。这通常涉及：
- ==内存管理==：如果返回的是指向动态分配内存的指针，调用者应该负责在适当的时候释放这块内存。
- ==资源释放==：如果返回的是其他类型的资源（例如文件句柄、网络连接等），调用者则需要负责释放这些资源。
> return 的作用：return 只是将指针返回，结构体仍然拥有指向内存的能力，但它不再负责内存的管理（例如释放内存）。返回指针后，调用者必须自己管理这块内存的生命周期

- 返回的只是指向缓冲区的指针（sb->buf），实际上并没有改变缓冲区的内存，只是让调用者从结构体中“获得”了这个内存块的控制权。所以这块内存还在，只是结构体不再管理它了
# 比较两个缓冲区
## memcmp函数
- memcmp() 是 C 标准库中用于比较内存块的函数。它可以比较两块内存区域的内容，并返回一个整数值，指示它们是否相等,如果两块内存内容相等，memcmp() 返回 0。
```c
int memcmp(const void *ptr1, const void *ptr2, size_t num);
```
参数说明：
ptr1：指向第一个内存块的指针。
ptr2：指向第二个内存块的指针。
num：要比较的字节数，即需要比较的内存大小。
- 如果两块内存内容不相等，返回一个整数：
如果第一个内存块的内容在字典顺序上小于第二个内存块，返回负值。
如果第一个内存块的内容在字典顺序上大于第二个内存块，返回正值。
## ==???== memcmp和strcmp
虽然 memcmp() 和 strcmp() 都是用来比较字符串的，但是 memcmp() 是按字节比较，而 strcmp() 是按字符逐一比较，memcmp() 适用于比较任意类型的内存块，而 strcmp() 只适用于比较以 \0 结束的字符串。
比较有限：memcmp() 比较的内存区域由第三个参数 num 指定，所以可以控制比较的长度。它不会关心内存区域是否是有效的字符串，只关心字节内容
# 清空sb
## 记得长度归零后,内容也要改变,要来一个'0'
## 用上指针指向元素的值p[]知识点
# 扩容
## 1.注意要计算可用空间!!如果不足,就要扩容
这个只是用来看需不需要扩展申请的内存空间的,所以不用写else的sit
## 注意对象!!是结构哦体里面的东西
是结构体里的buf,没让你再去造一个指针出来,是缓冲区不够,所以扩容缓冲区,所以肯定要操作缓冲区的首地址也就是buf
## 比较可以直接用相减的结果
if (sb->alloc - sb->len < extra)代替int remain=sb->alloc-sb->len;
    if(extra<=remain)
## 为什么要用realloc,不能malloc再一次原处指针
realloc 的作用相当于：
自动判断是否需要分配新内存。
==如果需要，会自动分配、复制旧数据。==
自动释放旧内存
malloc就还得再手动copy数据,更麻烦
## realloc
`realloc` 函数的参数是原始指针和新的内存大小。它的函数原型如下：

```c
void* realloc(void* ptr, size_t size);
```

### 参数说明：

1. **`ptr`**：
   - 这是你之前分配的内存块的指针，通常是通过 `malloc` 或 `calloc` 获取的。如果 `ptr` 是 `NULL`，`realloc` 会表现得像 `malloc`，即它会分配一块新的内存。
   - 如果 `ptr` 指向的是一个有效的内存块，`realloc` 会尝试调整这个内存块的大小。

2. **`size`**：
   - 这是你希望分配的新内存大小（以字节为单位）。`realloc` 会尝试扩展或缩小这个内存块以适应新的大小。
   - 如果新大小比原来小，内存会被收缩，可能会丢失原来多余的部分；
   - 如果新大小比原来大，`realloc` 会尝试扩展内存块。

### `realloc` 的行为：

- **成功时**：`realloc` 返回一个指向新分配内存的指针。如果内存扩展成功，新的指针可能和原来的指针相同，也可能不同（这取决于内存是否在原来的位置扩展）。这就是为什么你要将返回值赋给原始指针。
  
- **失败时**：如果内存分配失败，`realloc` 返回 `NULL`，并且原来的内存块不受影响，仍然有效。所以==你需要检查返回值是否为 `NULL`，以便处理内存分配失败的情况。==

### 示例：

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *arr = (int*) malloc(5 * sizeof(int));  // 初始分配 5 个整数的内存

    if (arr == NULL) {
        printf("Memory allocation failed!\n");
        return 1;
    }

    // 使用 realloc 扩展内存，分配更多的空间
    arr = (int*) realloc(arr, 10 * sizeof(int));  // 重新分配 10 个整数的内存

    if (arr == NULL) {
        printf("Memory reallocation failed!\n");
        return 1;
    }

    // 现在 arr 可以存储 10 个整数
    arr[5] = 100;  // 在新分配的内存中使用

    printf("arr[5] = %d\n", arr[5]);

    free(arr);  // 最后释放内存
    return 0;
}
```

### 关键点总结：

- **`realloc(ptr, size)`**：`ptr` 是你要调整大小的原内存块，`size` 是新的内存大小。
- **返回值**：返回一个指向新内存块的指针，或者在失败时返回 `NULL`。
- **处理失败**：记得在调用 `realloc` 后检查返回值，以确保内存分配成功。如果失败，你可以选择释放资源或者继续使用原内存块。



# ==未修改==追加数据
## 注意之前是写了这个函数,但不是进行后再下一个
所以在add里面也要先调用一边刚刚的判断if扩容的函数,再添加
## len在代表字符创所占字节数的时候,别忘了要+!('0')

## memcpy
memcpy() 是 C 标准库中的一个函数，用于从一个内存块复制数据到另一个内存块,
```c
void *memcpy(void *dest, const void *src, size_t n);
```
参数说明
dest：目标内存块的指针，数据将被复制到这个内存块中。
src：源内存块的指针，数据将从这个内存块中复制。
n：需要复制的字节数,memcpy() 返回目标内存块的指针（即 dest）,目标区域 dest 和源区域 src 不能重叠。如果内存区域可能重叠，应该使用 memmove() 代替

# addch
增加具体的东西,
直接用add函数,目标和源
# adds
# 获取字符串的长度
## strlen 
他的参数就是指针,他会识别到\0截止,并返回字符串中字符的个数



# add_buf
```c
void strbuf_addbuf(struct strbuf *sb, const struct strbuf *sb2)
{
  strbuf_add(sb,sb2,strlen(sb2));
```
注意,这样方式很错误,结构体指针不能放到strlen函数里,请注意类型
 strbuf_add(sb,sb2->buf,sb2->len);
## ==?== 不规范
使用追加字符串函数向缓冲区追加另一个缓冲区的内容。

这种做法并不规范！标准做法是使用追加函数向缓冲区追加另一个缓冲区的内容，长度为缓冲区的长度。

# 设置长度len
## ==?==
如果设置的长度大于缓冲区容量，则先增加缓冲区容量。设置长度，
## how在对应位置增加字符串结束标志'\0'
利用指针sb[len]
注意,就是len的位置不是len+1,因为数组是从0开始的,别忘了
### 指针[x]就是原本的偏移x

这种做法并不规范！函数默认：设置的长度一定小于容量。所以不需要判断长度或者增加容量，遇到问题应该直接抛出错误

# 计算 sb 目前仍可以向后追加的字符串长度
## 计算,那就直接return计算结果即可
## 注意,缓冲区包括'0',len不包括,所以相减之后还要再-1

# 向 sb 内存坐标为 pos 位置插入
## memmove函数


