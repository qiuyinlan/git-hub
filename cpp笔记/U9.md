int add(int a, int b) {  
    int sum = a + b;    
    return sum;          
}
函数的定义

指针:int *a,就是正常变量声明,中间多了一个*号
判断最大最小值:
数少的时候,我只想到让max一个一个去根据条件更新,但其实可以更简单
double max,min,mid;
	max=*a>*b?*a:*b;  
> 左边写要赋值的对象,右边写结果,要么是a要么b,方便极了
*a>*b?max=*a:max=*b;
    max>*c?:max=*c;.我这样多写了两个赋值号,更麻烦

	
	
	
	max=max>*c?max:*c;
	min=*a<*b?*a:*b;
	min=min<*c?min:*c;
	mid=*a+*b+*c-max-min;  ==直接加了再减去其他的,都不用再搞一个变量total,除非他很常用
	*a=min;
	*b=mid;
==?:语句针对对象少,结果只有两种的时候,很好用.本质就是条件+结果==

> 引用函数的返回值,直接引用函数名(输入参数)即可

> ==注意,在函数里定义的变量都是局部变量,在函数外是无法访问的,除非用return返回值==
所以,在主函数内,要重新声明变量
> 可以直接设abc,不用额外设一个指针,要他们的地址,直接doule *a,*b,*c;即可.记得用scanf函数让人家输入!!
> ==printf("%.2lf,%.2lf,%.2lf",zhi(&a,&b,&c),b,c);==
可以直接在printf的括号里直接引用函数名,就可以了,不用再设一个变量来接收函数的返回值了,且不用以double*a的形式输入,直接&a就可以了
> zhi 函数内部的逻辑也存在一些问题。例如，在计算中间值 mid 时，您使用了 total-max-min 的方式，这在某些情况下可能会导致精度损失，因为浮点数的加减运算可能会引入舍入误差。
> 既然要修改,那就要调用它,单起一行代码
 zhi(&a, &b, &c);
    
    printf("排序结果：%.2lf, %.2lf, %.2lf\n", a, b, c);
    return 0;
}
解释
现在，zhi函数没有返回值，而是直接通过指针修改传入的变量，因此函数的返回类型更改为 void。
计算 mid 的方法改为 *a + *b + *c - max - min，确保mid是三者的中间值。
在 main 中调用 zhi 后，a、b、c 的值会按照从小到大的顺序存放，然后直接输出 a, b, c 的排序结果。
> 在你的代码中，printf("%.2lf,%.2lf,%.2lf", zhi(&a, &b, &c), b, c);这一行的问题在于：

参数的求值顺序：在C语言中，函数参数的求值顺序是未定义的，也就是说编译器可能会先求zhi(&a, &b, &c)的值，也可能会先求b和c的值。因此，在执行zhi(&a, &b, &c)之前，b和c的值可能已经被传递给printf了，导致b和c的变化没有反映到printf输出中。
> f (*y < *x)
    {
        temp = *y;
        *y = *x;
        *x = temp;
    }
    if (*z < *x)
    {
        temp = *z;
        *z = *x;
        *x = temp;
    }
    if (*z < *y)
    {
        temp = *z;
        *z = *y;
        *y = temp;
    }这段代码的作用是什么
ChatGPT 说：
ChatGPT
这段代码的作用是对三个数进行排序，将三个变量所指向的值按从小到大的顺序排列。具体来说，它会将最小值存入 *x，中间值存入 *y，最大值存入 *z。
不仅如此,还可以不用借助他力
直接实时更新xyz的值,这样就可以不用再设一个变量了,直接用xyz来接收函数的返回值
冒泡排序也是实时更新
> 切忌在函数定义后面加上分号
> 终止程序进程：ctrl+c
输入数组可以用循环，别忘了！
for（i=0;i<n;i++）
{
scanf("%d",&a[i]);
}
利用sanf函数循环，放进去变量中


