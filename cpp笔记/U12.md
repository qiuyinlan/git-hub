指向字符的指针：char *
指向（指向字符的指针）的指针：char **  即指向指针的指针，指针嘛就是在后面多一个型号
# malloc
(char **)malloc(n * sizeof(char *)) 分配的是一块内存，它实际上是一个 内存块，而不是一个具体的数组。

为什么它是内存块而不是数组：
malloc 只会为你分配一块指定大小的内存区域，它并不会初始化内存的内容。这个内存区域只是按照你指定的大小被分配出来，里面的内容是 未定义的（可以是垃圾值）。
```c 
char **pt;    // 定义一个指向 char* 的指针
pt = (char **)malloc(3 * sizeof(char *));  // ==为3个 char* 指针分配内存==
pt[0] = "hello";
pt[1] = "world";
pt[2] = "abc";
pt 是动态分配的，大小不固定，可以根据需要扩展，指向的是动态分配的内存区域，存储的是指针数组。
```
if ((pt = (char **)malloc(n * sizeof(char *))) != NULL)
使用 malloc 动态分配内存，pt 将指向一个由 n 个 char * 组成的数组。
如果内存分配失败，malloc 会返回 ==NULL==，程序会打印错误信息并退出。


# 指针右边就是输入内存块(首地址)
ChatGPT 说：
ChatGPT
你说得对，指针右边的内存分配是为了存储数据，但如果只使用一个内存块来存储指针地址是不够的，还需要确保每个指针指向的内存区域可以存储实际的数据（如字符串）。这就是为什么你在代码中看到会有两次内存分配操作。

举个例子：
假设你想存储 n 个字符串：

第一步：为 char * 指针数组分配内存块
你通过 malloc 分配了一个内存块，它将存储 n 个 char * 类型的指针。
c
复制代码
pt = (char **)malloc(n * sizeof(char *));  // 为指针数组分配内存
这时，pt 只是一个数组，每个元素是一个 char *，但是这些 char * 并没有指向任何有效的内存空间。
第二步：为每个字符串分配内存
然后，你为每个 pt[i]（即每个指向字符串的指针）分配内存，确保它可以存储一个实际的字符串。例如，如果字符串的长度是 strlen(temp) + 1（+1 是为了包含字符串结束符 \0），你需要为每个指针分配足够的内存。
c
复制代码
pt[i] = (char *)malloc((strlen(temp) + 1) * sizeof(char));  // 为每个字符串分配内存
这样，每个 pt[i] 就会指向一个有效的内存区域，存储实际的字符串内容。
## 更详细的解释：
第一次 malloc：
为了存储多个 char * 指针，你分配了一块内存空间，实际上是一个 "指针数组"。但是这些指针本身并没有指向任何有效的数据。

第二次 malloc：
你为每个指针分配内存，使其指向可以存储具体字符串的区域。每个字符串都会有自己的内存块，这就是为什么你在代码中看到为每个单词分配内存的部分。

例子（详细展示内存分配过程）：
假设用户输入了 n = 2 个字符串（例如："hello" 和 "world"）。

第一次 malloc： 为 pt 分配内存，用来存储 2 个 char *：

c
复制代码
pt = (char **)malloc(2 * sizeof(char *));  // pt是一个指针数组，长度为2
此时 pt 内存块看起来像这样（存储的是指向字符串的指针）：

arduino
复制代码
pt[0]     pt[1]
|         |
v         v
NULL      NULL
第二次 malloc： 为每个 char * 分配内存，用来存储实际的字符串：

c
复制代码
pt[0] = (char *)malloc(6 * sizeof(char));  // "hello" + '\0' 需要6个字节
pt[1] = (char *)malloc(6 * sizeof(char));  // "world" + '\0' 需要6个字节
此时内存中，pt 数组指向的内存区域如下：

rust
复制代码
pt[0] -> "hello\0"
pt[1] -> "world\0"
结论：
## 你需要两次 malloc 来完成整个操作：
第一次 为存储指针分配内存块（数组）。
第二次 为每个指针指向的实际数据（字符串）分配内存。
只分配一个内存块并不足以存储实际的数据；你需要为每个指针指向的内存区域单独分配空间。

# 指针右边放的是地址：
当你写 p = &a; 或者 p = malloc(...) 时，实际上你是把 地址 赋给指针 p。

&a 是变量 a 的内存地址，p 存储的是 a 的内存位置（即 a 的地址）。
malloc() 返回的是分配的内存块的起始地址。malloc 分配了一块内存，并返回它的起始地址，指针 p 就指向这块内存的起始位置。

对于动态分配数组的操作，我们通常是先分配一块大的内存区域，然后根据需要逐步填充内容。这里有几个概念需要澄清：

# **分配内存的方式：**
当你需要动态分配数组时，**通常是通过 `malloc` 或 `calloc` 来一次性分配一定大小的内存**，然后通过指针逐步访问、操作这些内存块。为了确保你能够正确管理这些内存，通常是先分配一块大的内存区域，然后再在这块内存上进行更细粒度的操作。

#### 例子：分配一个字符数组来存储多个字符串
假设你需要存储多个字符串（比如从用户输入的单词），你可以先分配一个指向字符指针数组的内存空间，再逐个为每个字符串分配内存。

```c
int n; // 假设n为用户输入的单词数
char **pt;
pt = (char **)malloc(n * sizeof(char *));  // 为字符指针数组分配内存
```

接下来，每个 `pt[i]` 需要存储一个字符串，**每个字符串的大小可能不同**。所以，你要为每个字符串动态分配内存空间。

```c
pt[i] = (char *)malloc((strlen(temp) + 1) * sizeof(char));  // 为每个单词分配内存
strcpy(pt[i], temp);  // 复制temp字符串到pt[i]指向的内存
```

### 2. **为什么需要临时数组 `temp` 和 `strcpy`？**
在你的例子中，`temp` 是一个临时存储用户输入的字符数组。**原因**是，C语言不允许直接从标准输入流（`scanf`）输入到动态分配的内存块里，因此需要一个临时的字符数组 `temp` 来存储输入的数据，再通过 `strcpy` 函数将其复制到预先分配的内存区域。

具体来说，C 的标准库函数 `scanf` 不支持直接将输入写入到动态分配的内存区域。你只能将输入读取到一个现有的内存块（如数组），然后通过 `strcpy` 等方式将它复制到你为存储目标分配的内存中。

### 3. **不能直接输入到动态内存的原因：**
直接将用户输入的数据存入动态分配的内存空间不太可能的原因是 `scanf` 等函数的工作方式，它们会基于数组的地址进行操作。如果直接将动态分配的内存地址传递给 `scanf`，会因为内存没有被初始化，且可能无法正确处理字符串的结尾（如 `\0`），从而导致错误。

另外，`malloc` 分配的内存区域并不会自动初始化，所以你需要手动处理输入数据的复制和终止字符（`'\0'`），以保证字符串的完整性。

### 4. **如何直接输入到动态内存（理论上）？**
虽然 `scanf` 不允许直接输入到动态分配的内存，但如果你明确知道分配的内存大小，并且手动控制字符串的大小和终止字符，你是可以通过低级方式做到这一点（比如用 `fgets`）。

```c
char *pt;
pt = (char *)malloc(100 * sizeof(char));  // 假设要输入最大 100 个字符
fgets(pt, 100, stdin);  // 将输入直接存入分配的内存
```

不过这种做法要小心处理字符串的末尾符号 `\0`，以及防止越界写入。

### 结论：
- **动态分配内存** 时，通常是先分配一块大内存，再根据需要逐步填充数据。
- **临时数组 `temp` 和 `strcpy`** 的使用是因为 `scanf` 和类似的函数不能直接将输入写入到动态分配的内存中。你需要一个已分配的内存区域（如 `temp`）来临时存储输入的数据，然后再将其复制到目标内存区域。
- **无法直接输入到动态内存** 是由于 C 语言标准库函数（如 `scanf`）的工作原理，以及动态内存的特性（如未初始化，大小不固定等）。

- 深拷贝：复制对象的值，并为指针类型的字段分配新的内存，确保每个对象拥有独立的内存。深拷贝通常需要手动实现
复制值就是strcpy